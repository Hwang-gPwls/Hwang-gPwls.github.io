### ****this 란 무엇일까?****

this란 JavaScript 예약어이다.

`this`가 어떤 값과 연결되는 지는 `this`의 바인딩을 통해서 확인해 볼 수 있다. 바인딩이란, `this`의 호출 방식에 따라서 `this`가 특정 '객체'에 연결되는 것이다. `this`의 바인딩은 일반 함수 내부, 메서드 내부, 생성자 함수 내부, `Call, Apply, Bind`를 통한 '호출 방식'으로 나눠서 살펴볼 수 있다.

- ****전역에 선언된 함수에서****  `this`는 글로벌 객체와 바인딩된다.

```jsx
console.log(this === window); // true;
```

**function 키워드로 생성한 일반함수와 화살표 함수의 가장 큰 차이점이 바로 this이다. (이를 Lexical this (렉시컬 this)라고 한다.)**

**화살표 함수 안에서 this는 언제나 상위 스코프의 this를 가리킨다.** 일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되지 않고, 함수를 호출 할 때 함수가 어떻게 호출 되는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다. 화살표 함수의 this 바인딩 객체 결정 방식은 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프와 유사하다. 화살표 함수는 call, apply, bind 메소드를 사용하여 this를 변경할 수 없다.

- 메서드 내부에서의 `this`는 메서드를 호출한 객체와 바인딩된다.

```jsx
let ryan = {
  firstName: "Ryan",
  lastName: "Kim",
  driveCar() {
    console.log(`${this.firstName} drives a car.`)
  }
}

ryan.driveCar(); // 'Ryan drives a car.
```

- 생성자 함수 내부에서 `this`는 생성자 함수가 생헐할 인스턴스와 바인딩된다.

```jsx
function person() {
  this.firstName = "Ryan",
  this.lastName = "Kim",
    this.start = function() {
console.log(`${this.firstName} drives a car.`)};
};

let person1 = new person();
console.log(person1); // person { firstName: 'Ryan', lastName: 'Kim', start: ƒ (), __proto__: person { constructor: ƒ person() } }
```

- **Call, Apply, Bind** 메서드 사용 시, 메서드에 첫 번째 인수로 전달하는 객체에 바인딩 된다.
    
    `Call`과 `Apply`메서드는 기본적으로 함수를 호출하는 역할을 한다. 그렇다면 기존 함수 호출과의 차이점은 무엇일까? 그것은 바로, 해당 메서드를 사용해 함수를 '실행'하면, 함수의 첫 번째 인자로 전달하는 객체에 `this`를 '바인딩'할 수 있다는 것이다. 이를 통해서 유사 배열 `arguments`객체에 배열 메서드를 사용할 수 있다. 반면에, `bind`는 첫 번째 인자를 `this`
    에 바인딩하지만 **함수를 실행하지 않으며,**새로운 함수를 반환한다.
